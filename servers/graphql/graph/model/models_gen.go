// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"

	"github.com/sergey23144V/BotanyBackend/servers/g-rpc/api"
)

// Мутации для работы с сущностью анализа
type AnalysisMutation struct {
	// Создать новый анализ
	//
	// Аргументы:
	// - input: Входные данные для создания анализа
	//
	// Возвращает:
	// - Analysis: Созданный объект анализа
	CreatAnalysis *api.Analysis `json:"creatAnalysis"`
	// Повторить (обновить) анализ
	//
	// Аргументы:
	// - input: Входные данные для обновления анализа
	//
	// Возвращает:
	// - Analysis: Обновленный объект анализа
	RepeatedAnalysis *api.Analysis `json:"repeatedAnalysis"`
	// Удалить анализ по уникальному идентификатору
	//
	// Аргументы:
	// - id: Уникальный идентификатор анализа
	//
	// Возвращает:
	// - BoolResponse: Ответ с результатом операции (успешно/неуспешно)
	DeleteAnalysis *api.BoolResponse `json:"deleteAnalysis"`
}

// Запросы для работы с сущностью анализа
type AnalysisQuery struct {
	// Получить анализ по уникальному идентификатору
	//
	// Аргументы:
	// - id: Уникальный идентификатор анализа
	//
	// Возвращает:
	// - Analysis: Объект анализа
	GetAnalysis *api.Analysis `json:"getAnalysis"`
	// Получить список анализов с учетом пагинации
	//
	// Аргументы:
	// - pages: Параметры пагинации
	//
	// Возвращает:
	// - AnalysisList: Список анализов с информацией о страницах
	GetListAnalysis *api.AnalysisList `json:"getListAnalysis"`
}

// Мутации для работы с аутентификацией
type AuthMutation struct {
	// Регистрация нового пользователя
	//
	// Аргументы:
	// - data: Входные данные для регистрации пользователя
	//
	// Возвращает:
	// - SignInUserResponse: Ответ с токенами и статусом
	SignUpUser *api.SignInUserResponse `json:"signUpUser,omitempty"`
	// Регистрация нового суперпользователя
	//
	// Аргументы:
	// - data: Входные данные для регистрации суперпользователя
	//
	// Возвращает:
	// - SignInUserResponse: Ответ с токенами и статусом
	SignUpSuperUser *api.SignInUserResponse `json:"signUpSuperUser,omitempty"`
	// Авторизация пользователя
	//
	// Аргументы:
	// - data: Входные данные для авторизации пользователя
	//
	// Возвращает:
	// - SignInUserResponse: Ответ с токенами и статусом
	SignInUser *api.SignInUserResponse `json:"signInUser,omitempty"`
	// Обновление токена доступа
	//
	// Аргументы:
	// - data: Входные данные для обновления токена
	//
	// Возвращает:
	// - SignInUserResponse: Ответ с новыми токенами и статусом
	RefreshToken *api.SignInUserResponse `json:"refreshToken,omitempty"`
}

// Мутации для работы с экоморфами
type EcomorphMutation struct {
	// Вставка нового экоморфа
	//
	// Аргументы:
	// - input: Входные данные для создания экоморфа
	//
	// Возвращает:
	// - Ecomorph: Созданный объект экоморфа
	InsertEcomorph *api.Ecomorph `json:"insertEcomorph"`
	// Обновление существующего экоморфа
	//
	// Аргументы:
	// - input: Входные данные для обновления экоморфа
	//
	// Возвращает:
	// - Ecomorph: Обновленный объект экоморфа
	UpdateEcomorph *api.Ecomorph `json:"updateEcomorph"`
	// Удаление экоморфа по его уникальному идентификатору
	//
	// Аргументы:
	// - id: Уникальный идентификатор экоморфа
	//
	// Возвращает:
	// - BoolResponse: Ответ с результатом операции
	DeleteEcomorphByID *api.BoolResponse `json:"deleteEcomorphById"`
}

// Запросы для работы с экоморфами
type EcomorphQuery struct {
	// Получить экоморф по его уникальному идентификатору
	//
	// Аргументы:
	// - id: Уникальный идентификатор экоморфа
	//
	// Возвращает:
	// - Ecomorph: Объект экоморфа
	GetEcomorphByID *api.Ecomorph `json:"getEcomorphById"`
	// Получить список экоморфов с фильтрацией и постраничной информацией
	//
	// Аргументы:
	// - pages: Параметры запроса списка экоморфов
	//
	// Возвращает:
	// - ListEcomorph: Список экоморфов с постраничной информацией
	GetListEcomorph *api.EcomorphsList `json:"getListEcomorph"`
}

// Мутации для работы с сущностями экоморфов
type EcomorphsEntityMutation struct {
	// Вставка новой сущности экоморфов
	//
	// Аргументы:
	// - input: Входные данные для создания сущности экоморфов
	//
	// Возвращает:
	// - EcomorphsEntity: Созданный объект сущности экоморфов
	InsertEcomorphEntity *api.EcomorphsEntity `json:"insertEcomorphEntity,omitempty"`
	// Обновление существующей сущности экоморфов
	//
	// Аргументы:
	// - input: Входные данные для обновления сущности экоморфов
	//
	// Возвращает:
	// - EcomorphsEntity: Обновленный объект сущности экоморфов
	UpdateEcomorphEntity *api.EcomorphsEntity `json:"updateEcomorphEntity,omitempty"`
	// Удаление сущности экоморфов по её уникальному идентификатору
	//
	// Аргументы:
	// - id: Уникальный идентификатор сущности экоморфов
	//
	// Возвращает:
	// - BoolResponse: Ответ с результатом операции
	DeleteEcomorphEntityByID *api.BoolResponse `json:"deleteEcomorphEntityByID,omitempty"`
}

// Запросы для работы с сущностями экоморфов
type EcomorphsEntityQuery struct {
	// Получить сущность экоморфов по её уникальному идентификатору
	//
	// Аргументы:
	// - id: Уникальный идентификатор сущности экоморфов
	//
	// Возвращает:
	// - EcomorphsEntity: Объект сущности экоморфов
	GetEcomorphEntityByID *api.EcomorphsEntity `json:"getEcomorphEntityByID,omitempty"`
	// Получить список сущностей экоморфов с фильтрацией и постраничной информацией
	//
	// Аргументы:
	// - pages: Параметры запроса списка сущностей экоморфов
	//
	// Возвращает:
	// - EcomorphsEntityList: Список сущностей экоморфов с постраничной информацией
	GetAllEcomorphEntity *api.EcomorphsEntityList `json:"getAllEcomorphEntity,omitempty"`
}

// Запрос с идентификатором
type IDRequest struct {
	// Уникальный идентификатор
	ID string `json:"id"`
}

// Запросы для работы с изображениями
type ImgQuery struct {
	// Получить изображение по идентификатору
	GetImgByID *api.Img `json:"getImgByID,omitempty"`
	// Получить список изображений с постраничным запросом
	GetListImg *api.ImgList `json:"getListImg,omitempty"`
}

// Корневая мутация для работы с различными сущностями
type Mutation struct {
}

// Корневой запрос для работы с различными сущностями
type Query struct {
}

// Мутации для работы с трансектами
type TransectMutation struct {
	// Создать новый трансект
	CreateTransect *api.Transect `json:"createTransect,omitempty"`
	// Обновить информацию о трансекте
	UpTransect *api.Transect `json:"upTransect,omitempty"`
	// Добавить место проведения опыта к трансекту
	AddTrialSiteToTransect *api.Transect `json:"addTrialSiteToTransect,omitempty"`
	// Удалить трансект по идентификатору
	DeleteTransect *api.BoolResponse `json:"deleteTransect,omitempty"`
}

// Запросы для работы с трансектами
type TransectQuery struct {
	// Получить трансект по идентификатору
	GetTransect *api.Transect `json:"getTransect,omitempty"`
	// Получить список всех трансектов с постраничным запросом
	GetAllTransect *api.TransectList `json:"getAllTransect,omitempty"`
}

// Мутации для работы с местами проведения опытов и растениями
type TrialSiteMutation struct {
	// Создать новое место проведения опыта
	CreateTrialSite *api.TrialSite `json:"createTrialSite,omitempty"`
	// Обновить информацию о месте проведения опыта
	UpTrialSite *api.TrialSite `json:"upTrialSite,omitempty"`
	// Добавить растения к месту проведения опыта
	AddPlantsToTrialSite *api.TrialSite `json:"addPlantsToTrialSite,omitempty"`
	// Удалить место проведения опыта по идентификатору
	DeleteTrialSite *api.BoolResponse `json:"deleteTrialSite,omitempty"`
	// Создать новое растение
	CreatePlant *api.Plant `json:"createPlant,omitempty"`
	// Обновить информацию о растении
	UpdatePlant *api.Plant `json:"updatePlant,omitempty"`
	// Удалить растение по идентификатору
	DeletePlant *api.BoolResponse `json:"deletePlant,omitempty"`
}

// Запросы для работы с местами проведения опытов и растениями
type TrialSiteQuery struct {
	// Получить место проведения опыта по идентификатору
	GetTrialSite *api.TrialSite `json:"getTrialSite,omitempty"`
	// Получить список всех мест проведения опытов с постраничным запросом
	GetAllTrialSite *api.TrialSiteList `json:"getAllTrialSite,omitempty"`
	// Получить растение по идентификатору
	GetPlant *api.Plant `json:"getPlant,omitempty"`
	// Получить список всех растений с постраничным запросом
	GetAllPlant *api.PlantList `json:"getAllPlant,omitempty"`
}

// Мутации для управления типами растений
type TypePlantMutation struct {
	// Создать новый тип растения
	CreateTypePlant *api.TypePlant `json:"createTypePlant,omitempty"`
	// Обновить информацию о типе растения
	UpdateTypePlant *api.TypePlant `json:"updateTypePlant,omitempty"`
	// Добавить сущность экоморфа к типу растения
	AddEcomorphsEntityToTypePlant *api.TypePlant `json:"addEcomorphsEntityToTypePlant,omitempty"`
	// Удалить тип растения
	DeleteTypePlant *api.BoolResponse `json:"deleteTypePlant,omitempty"`
}

// Запрос информации о типе растения по его идентификатору
type TypePlantQuery struct {
	// Получить информацию о типе растения по его идентификатору
	GetTypePlant *api.TypePlant `json:"getTypePlant,omitempty"`
	// Получить список всех типов растений с возможностью постраничного запроса
	GetAllTypePlant *api.TypePlantList `json:"getAllTypePlant,omitempty"`
}

// Запросы для работы с пользователями
type UserQuery struct {
	// Получить текущего авторизованного пользователя
	//
	// Возвращает:
	// - User: Объект текущего пользователя
	GetMe *api.User `json:"getMe,omitempty"`
}

// Перечисление типов ролей пользователей
type RoleType string

const (
	// Суперпользователь с расширенными правами
	RoleTypeSuperUser RoleType = "SuperUser"
	// Обычный пользователь с ограниченными правами
	RoleTypeNormalUser RoleType = "NormalUser"
)

var AllRoleType = []RoleType{
	RoleTypeSuperUser,
	RoleTypeNormalUser,
}

func (e RoleType) IsValid() bool {
	switch e {
	case RoleTypeSuperUser, RoleTypeNormalUser:
		return true
	}
	return false
}

func (e RoleType) String() string {
	return string(e)
}

func (e *RoleType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RoleType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RoleType", str)
	}
	return nil
}

func (e RoleType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Типы анализа
type TypeAnalysis string

const (
	// Анализ растений
	TypeAnalysisTypeAnalysisPlant TypeAnalysis = "TypeAnalysisPlant"
	// Анализ транекта
	TypeAnalysisTypeAnalysisTransect TypeAnalysis = "TypeAnalysisTransect"
)

var AllTypeAnalysis = []TypeAnalysis{
	TypeAnalysisTypeAnalysisPlant,
	TypeAnalysisTypeAnalysisTransect,
}

func (e TypeAnalysis) IsValid() bool {
	switch e {
	case TypeAnalysisTypeAnalysisPlant, TypeAnalysisTypeAnalysisTransect:
		return true
	}
	return false
}

func (e TypeAnalysis) String() string {
	return string(e)
}

func (e *TypeAnalysis) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TypeAnalysis(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TypeAnalysis", str)
	}
	return nil
}

func (e TypeAnalysis) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
